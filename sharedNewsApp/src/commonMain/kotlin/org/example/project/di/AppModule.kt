package org.example.project.di

import app.cash.sqldelight.db.SqlDriver
import io.ktor.client.HttpClient
import kotlinx.serialization.json.Json
import org.example.project.data.database.DatabaseHelper
import org.example.project.data.database.DatabaseHelperImpl
import org.example.project.di.KtorClientFactory
import org.example.project.data.remote.RemoteHelper
import org.example.project.data.remote.RemoteHelperImpl
import org.example.project.database.NewsDatabase
import org.example.project.ui.news.NewsViewModel

/**
 * Dependency injection module providing application-wide singleton instances.
 *
 * This object serves as a simple service locator pattern implementation,
 * managing the creation and lifecycle of core application dependencies.
 * All dependencies are lazily initialized to improve application startup
 * performance and ensure they're only created when actually needed.
 *
 * The module centralizes dependency configuration and provides a single
 * source of truth for shared instances across the application.
 */
object AppModule {

    var applicationContext:Any? = null

    /**
     * Lazy-initialized HTTP client for making network requests.
     *
     * Uses platform-specific HTTP engines through [KtorClientFactory], which is an
     * expect class that provides the appropriate engine for each target platform:
     * - **Darwin engine** for iOS (NSURLSession-based)
     * - **Android engine** for Android (OkHttp-based)
     *
     * @see HttpClient for client configuration options
     * @see KtorClientFactory for expect/actual factory implementation details
     */
    val ktorClient: HttpClient by lazy { KtorClientFactory().createClient() }

    /**
     * Lazy-initialized JSON serialization configuration.
     *
     * Configured with ignoreUnknownKeys = true to provide resilience
     * against API changes by ignoring unexpected fields in JSON responses.
     * This prevents parsing errors when the server adds new fields.
     *
     * @see Json for additional configuration options
     */
    val json by lazy {
        Json {
            ignoreUnknownKeys = true
        }
    }

    /**
     * Lazy-initialized remote data access helper.
     *
     * Provides the main interface for all remote API operations.
     * Uses the concrete RemoteHelperImpl implementation which leverages
     * the shared ktorClient and json instances for consistency.
     *
     * @see RemoteHelper for the interface contract
     * @see RemoteHelperImpl for the concrete implementation
     */
    val remoteHelper: RemoteHelper by lazy { RemoteHelperImpl() }

    /**
     * Factory method for creating NewsViewModel instances.
     */
    fun provideNewsViewModel() = NewsViewModel()

    /**
     * Lazy-initialized SQLDelight database driver.
     *
     * This driver is responsible for platform-specific database operations.
     * It's created using [DatabaseDriverFactory], which is an expect class
     * that provides the appropriate SQL driver for each target platform
     * (e.g., AndroidSqliteDriver for Android, NativeSqliteDriver for iOS).
     * The `applicationContext` is passed to the factory to enable initialization Android
     *
     * @see SqlDriver for the SQLDelight driver interface
     * @see DatabaseDriverFactory for the expect/actual factory implementation
     */
    private val databaseDriver: SqlDriver by lazy { DatabaseDriverFactory().createDriver(applicationContext) }

    /**
     * Lazy-initialized SQLDelight database instance.
     *
     * This provides the main entry point for interacting with the application's
     * local database, generated by SQLDelight. It uses the [databaseDriver]
     * for its underlying database operations.
     *
     * @see NewsDatabase for the generated SQLDelight database class
     * @see SqlDriver for the underlying driver
     */
    val database by lazy { NewsDatabase(databaseDriver) }

    /**
     * Lazy-initialized database helper.
     *
     * Provides a higher-level abstraction for database interactions,
     * encapsulating common database operations and queries. It utilizes
     * the [database] instance to perform these operations.
     * This promotes separation of concerns and simplifies data access logic
     * in other parts of the application.
     *
     * @see DatabaseHelper for the interface contract
     * @see DatabaseHelperImpl for the concrete implementation
     * @see NewsDatabase for the underlying SQLDelight database instance
     */
    val databaseHelper: DatabaseHelper by lazy { DatabaseHelperImpl() }

}